'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelfPathname = exports.getMatchedPath = exports.getMatch = exports.shouldMatch = exports.removeMatch = exports.getLastMatchedRoute = exports.addMatch = exports.clearMatch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Util = require('./Util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** record the matched component by asc order */
var routeMatch = [];

/** clear all matched component, used when path changed */
var clearMatch = function clearMatch() {
  routeMatch = [];
};

/** when a component matched the path and should to be mount, record it */
var addMatch = function addMatch(instance) {
  if (routeMatch.length > 0) {
    routeMatch.forEach(function (item) {
      if (item === instance) {
        return;
      }
    });
  }
  routeMatch.push(instance);
};

/** get last matched route */
var getLastMatchedRoute = function getLastMatchedRoute() {
  return routeMatch.length ? routeMatch[routeMatch.length - 1] : null;
};

/** get match component */
var getMatch = function getMatch(index) {
  if (routeMatch.length === 0) {
    return null;
  }
  if (index < 0 || index >= routeMatch.length) {
    return routeMatch[routeMatch.length - 1];
  }
  return routeMatch[index];
};

/** get matched path, all components matched will be counted */
var getMatchedPath = function getMatchedPath() {
  if (routeMatch.length === 0) {
    return '';
  }
  var path = [];
  routeMatch.forEach(function (item) {
    if (item.matcher) path.push(item.matcher.matchStr);
  });
  return path.join('');
};

/**
 * get addtive mathced component path
 * different with getMatchedPath
 */
var getSelfPathname = function getSelfPathname(obj) {
  if (!obj.context) {
    return '';
  }
  var path = [];
  (obj.context.routes || []).forEach(function (item) {
    // path.push(resetPath(item.props.path))
    path.push(item.matcher ? item.matcher.matchStr : '');
  });
  path.push(obj.matcher ? obj.matcher.matchStr : '');
  return path.join('');
};

/** when a component unmount, remove it */
var removeMatch = function removeMatch(instance) {
  routeMatch.forEach(function (item, index) {
    if (item === instance) {
      routeMatch = routeMatch.splice(index, 1);
      return;
    }
  });
};

/**
 * 'index' property support
 * when no component matched, this one will match if condition
 * the condition is 'when no matched, it's parent is last matched one'
 */
// const checkMissMatch = (child) => {
//   const parent = routeMatch.length>0? routeMatch[0] : ''
//   if(!child) {
//     return
//   }
//   setTimeout(()=> {
//     if(routeMatch.length===0) {
//       if(parent === '') {
//         child.setToMount()
//       }
//       return
//     }
//     if(routeMatch[routeMatch.length-1] === parent) {
//       child.setToMount()
//       return
//     }
//   }, 0)
// }

/**
 * to judge if a component should match
 * the condition is 'if it's the direct child of last matched component'
 */
var shouldMatch = function shouldMatch(instance) {
  var match = false;
  if (routeMatch.length === 0) {
    match = true;
  } else {
    match = (0, _Util.reactContains)(routeMatch[routeMatch.length - 1], instance);
  }
  return match;
};

exports.clearMatch = clearMatch;
exports.addMatch = addMatch;
exports.getLastMatchedRoute = getLastMatchedRoute;
exports.removeMatch = removeMatch;
exports.shouldMatch = shouldMatch;
exports.getMatch = getMatch;
exports.getMatchedPath = getMatchedPath;
exports.getSelfPathname = getSelfPathname;